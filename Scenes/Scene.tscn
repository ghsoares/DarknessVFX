[gd_scene load_steps=13 format=2]

[ext_resource path="res://icon.png" type="Texture" id=1]
[ext_resource path="res://Materials/DarkRift.tres" type="Material" id=2]

[sub_resource type="Shader" id=1]
code = "shader_type spatial;
render_mode unshaded;

const int MAX_STEPS = 128;
const float MAX_DISTANCE = 999.0;
const float SURFACE_DISTANCE = 0.005;
const float NORMAL_PRECISION = 1f;

uniform sampler2D noiseTex;
uniform vec2 tiling = vec2(64.0);
uniform vec2 warpTiling = vec2(256.0);
uniform float warpAmount = 32.0;

uniform float riftDepth = 512.0;
uniform float riftRadius = 32f;
uniform float riftPerc : hint_range(0.0, 1.0) = 1.0;

uniform float riftCrackOff = .5f;
uniform float riftCrackWidth = .1f;
uniform float lightSteps = 8.0;
uniform vec3 sunDir = vec3(1.0, -1.0, 1.0);
uniform sampler2D lightGrad;

uniform sampler2D groundTexture;
uniform vec2 groundTiling = vec2(256, 256);
uniform vec4 groundColor : hint_color;
uniform vec4 riftColor : hint_color;
uniform vec4 riftEmission : hint_color;
uniform float riftBottomPower = 2.0f;

void vertex() {
	POSITION = vec4(VERTEX, 1f);
}

float EaseInOutCirc(float x) {
return x < 0.5
  ? (1f - sqrt(1f - pow(2f * x, 2f))) / 2f
  : (sqrt(1f - pow(-2f * x + 2f, 2f)) + 1f) / 2f;
}

float SampleNoise(vec3 pos) {
	vec2 warpUv = pos.xz / warpTiling;
	
	float n = (texture(noiseTex, warpUv).r * 2f - 1f) * 3.1415;
	vec2 warp = vec2(cos(n), sin(n)) * warpAmount;
	
	vec2 uv = (pos.xz + warp) / tiling;
	n = texture(noiseTex, uv).r;
	
	return n;
}

float SampleRift(vec3 pos) {
	float n = SampleNoise(pos);
	vec2 riftPos = vec2(0.0);
	float riftSqrDst = pow(riftPos.x - pos.x, 2.0) + pow(riftPos.y - pos.z, 2.0);
	float riftRad = riftRadius * riftRadius;
	
	float riftT = riftSqrDst / riftRad;
	riftT -= clamp(1.0 - riftT, 0.0, 1.0) * riftPerc * .5f;
	
	float crack = 1.0 - abs(n - riftCrackOff) / riftCrackWidth;
	n = mix(n, crack, clamp(riftT * 2f, 0.0, 1.0));
	n -= riftT;
	n -= 1.0;
	n += riftPerc;
	
	n = clamp(n * 2.0, 0.0, 1.0);
	float disp = mix(0.0, riftDepth, n);
	
	return disp;
}

void SampleDistance(vec3 pos, out vec3 rgb, out float dst, out vec3 emissive) {
	rgb = texture(groundTexture, pos.xz / groundTiling).rgb * groundColor.rgb;
	dst = MAX_DISTANCE;
	emissive = vec3(0.0);
	
	/*vec3 spPos = vec3(0.0, riftPerc * 64.0 - 64.0, 0.0);
	float spRadius = 16.0;
	dst = length(pos - spPos) - spRadius;*/
	
	float disp = SampleRift(pos);
	
	float planeDst = pos.y + disp;
	dst = min(dst, planeDst);
	
	if (disp > 0.0){
		rgb = riftColor.rgb;
		//emissive = riftEmission.rgb;
	} 
	float dispT = -pos.y - riftDepth;
	dispT = 1.0 - clamp(-dispT / 8f, 0.0, 1.0);
	emissive = riftEmission.rgb * dispT * riftBottomPower;
}

float SampleDistanceSimple(vec3 pos) {
	float disp = SampleRift(pos);
	
	float planeDst = pos.y + disp;
	float dst = planeDst;
	
	return dst;
}

vec3 GetNormal(vec3 p) {
	float d = SampleDistanceSimple(p);
	vec2 e = vec2(NORMAL_PRECISION, 0.0);
	vec3 n = d - vec3(
		SampleDistanceSimple(p - e.xyy),
		SampleDistanceSimple(p - e.yxy),
		SampleDistanceSimple(p - e.yyx)
	);
	return normalize(n);
}

void Raymarch(vec3 origin, vec3 dir, out vec3 hitPos, out float d, out vec3 normal, out vec3 rgb, out vec3 emissive) {
	d = 0.0;
	rgb = vec3(0.0);
	emissive = vec3(0.0);
	for (int i = 0; i < MAX_STEPS; ++i) {
		vec3 p = origin + dir * d;
		//vec4 scene = SampleDistance(p);
		vec3 sceneRgb;
		float sceneDst;
		vec3 sceneEmissive;
		SampleDistance(p, sceneRgb, sceneDst, sceneEmissive);
		rgb = sceneRgb;
		emissive = sceneEmissive;
		d += (sceneDst < 0.0 ? sceneDst * .2f : sceneDst * .2f);
		if (d > MAX_DISTANCE || sceneDst < SURFACE_DISTANCE) {
			break;
		}
	}

	hitPos = origin + dir * d;
	normal = GetNormal(hitPos);
}

void fragment() {
	// REGION Gets ray dir from camera, grabbed from here: https://github.com/Zylann/godot_sdf_blender/blob/master/addons/zylann.sdf_blender/raymarch.shader
	vec3 ndc = vec3(SCREEN_UV, 0.0) * 2.0 - 1.0;
	vec4 view_coords = INV_PROJECTION_MATRIX * vec4(ndc, 1.0);
	view_coords.xyz /= view_coords.w;
	vec3 world_cam_pos = (CAMERA_MATRIX * vec4(0.0, 0.0, 0.0, 1.0)).xyz;
	vec4 world_coords = CAMERA_MATRIX * vec4(view_coords.xyz, 1.0);
	
	vec3 ray_origin = world_coords.xyz;
	vec3 ray_dir = normalize(world_coords.xyz - world_cam_pos);
	// ENDREGION
	
	vec3 hitPos;
	float hitDst;
	vec3 hitNormal;
	vec3 rgb;
	vec3 emissive;
	
	Raymarch(ray_origin, ray_dir, hitPos, hitDst, hitNormal, rgb, emissive);
	if (hitDst >= MAX_DISTANCE) discard;
	
	float dt = dot(hitNormal, -normalize(sunDir)) * .5f + .5f;
	dt = floor(dt * lightSteps) / (lightSteps - 1.0);
	vec3 alb = rgb * texture(lightGrad, vec2(dt)).rgb;
	alb += emissive;
	
	ALBEDO = alb;
	DEPTH = hitDst / MAX_DISTANCE;
}




"

[sub_resource type="Gradient" id=2]
offsets = PoolRealArray( 0.455399, 1 )
colors = PoolColorArray( 0.441406, 0.441406, 0.441406, 1, 1, 1, 1, 1 )

[sub_resource type="GradientTexture" id=3]
gradient = SubResource( 2 )

[sub_resource type="OpenSimplexNoise" id=4]

[sub_resource type="NoiseTexture" id=5]
seamless = true
noise = SubResource( 4 )

[sub_resource type="ShaderMaterial" id=6]
shader = SubResource( 1 )
shader_param/tiling = Vector2( 256, 256 )
shader_param/warpTiling = Vector2( 512, 512 )
shader_param/warpAmount = 16.0
shader_param/riftDepth = 32.0
shader_param/riftRadius = 128.0
shader_param/riftPerc = 1.0
shader_param/riftCrackOff = 0.465
shader_param/riftCrackWidth = 0.2
shader_param/lightSteps = 32.0
shader_param/sunDir = Vector3( 1, -1, 1 )
shader_param/groundTiling = Vector2( 64, 64 )
shader_param/groundColor = Color( 0.454902, 0.454902, 0.454902, 1 )
shader_param/riftColor = Color( 0.207843, 0, 0.180392, 1 )
shader_param/riftEmission = Color( 0.494118, 0, 0.239216, 1 )
shader_param/riftBottomPower = 2.0
shader_param/noiseTex = SubResource( 5 )
shader_param/lightGrad = SubResource( 3 )
shader_param/groundTexture = ExtResource( 1 )

[sub_resource type="QuadMesh" id=7]
size = Vector2( 2, 2 )

[sub_resource type="PlaneMesh" id=8]
size = Vector2( 64, 64 )

[sub_resource type="SphereMesh" id=9]
radius = 8.0
height = 16.0

[sub_resource type="Animation" id=10]
length = 8.0
tracks/0/type = "value"
tracks/0/path = NodePath("Parallax:material_override:shader_param/riftInnerRadius")
tracks/0/interp = 1
tracks/0/loop_wrap = true
tracks/0/imported = false
tracks/0/enabled = true
tracks/0/keys = {
"times": PoolRealArray( 0, 3, 3.8, 8 ),
"transitions": PoolRealArray( 0.5, 0.5, 0.5, -2 ),
"update": 0,
"values": [ 0.0, 0.0, 0.0, 10.0 ]
}
tracks/1/type = "value"
tracks/1/path = NodePath("Parallax:material_override:shader_param/riftRadius")
tracks/1/interp = 1
tracks/1/loop_wrap = true
tracks/1/imported = false
tracks/1/enabled = true
tracks/1/keys = {
"times": PoolRealArray( 0, 3 ),
"transitions": PoolRealArray( 0.5, 0.5 ),
"update": 0,
"values": [ 32.0, 32.0 ]
}
tracks/2/type = "value"
tracks/2/path = NodePath("Parallax:material_override:shader_param/riftPercentage")
tracks/2/interp = 1
tracks/2/loop_wrap = true
tracks/2/imported = false
tracks/2/enabled = true
tracks/2/keys = {
"times": PoolRealArray( 0, 3, 5.5, 8 ),
"transitions": PoolRealArray( 0.5, 0.5, 1, -2 ),
"update": 0,
"values": [ 0.0, 0.0, 1.0, 1.0 ]
}
tracks/3/type = "value"
tracks/3/path = NodePath("Parallax:material_override:shader_param/riftFogAmplitude")
tracks/3/interp = 1
tracks/3/loop_wrap = true
tracks/3/imported = false
tracks/3/enabled = true
tracks/3/keys = {
"times": PoolRealArray( 0, 3, 5.5 ),
"transitions": PoolRealArray( 1, 1, 1 ),
"update": 0,
"values": [ 0.0, 0.0, 3.0 ]
}

[node name="Scene" type="Spatial"]

[node name="RayMarch" type="MeshInstance" parent="."]
visible = false
material_override = SubResource( 6 )
extra_cull_margin = 9999.0
mesh = SubResource( 7 )
material/0 = null

[node name="Parallax" type="MeshInstance" parent="."]
transform = Transform( 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0.02, 0 )
material_override = ExtResource( 2 )
mesh = SubResource( 8 )
material/0 = null

[node name="MeshInstance" type="MeshInstance" parent="."]
mesh = SubResource( 9 )
material/0 = null

[node name="Camera" type="Camera" parent="."]
transform = Transform( 0.735724, 0.274982, -0.618947, 0, 0.913869, 0.406009, 0.677282, -0.29871, 0.672355, -12.0351, 6.62905, 13.0033 )
visible = false
current = true

[node name="Anim" type="AnimationPlayer" parent="."]
anims/RiftAppear = SubResource( 10 )
